{"file_contents":{"main.scala":{"content":"import scala.collection.parallel.CollectionConverters._\n\n// Envuelve todo el código en un objeto\nobject Main extends App {\n\n  // --- DEFINICIONES DE DATOS (DEL PDF) ---\n  case class Aeropuerto(Cod: String, X: Int, Y: Int, GMT: Int)\n  case class Vuelo(Aln: String, Num: Int, Org: String, HS: Int, MS: Int, Dst: String, HL: Int, ML: Int, Esc: Int)\n  type Itinerario = List[Vuelo]\n\n  // --- DATOS DE PRUEBA (DEL PDF) ---\n  val aeropuertosCurso: List[Aeropuerto] = List(\n    Aeropuerto(\"CLO\", 100, 200, -500), // Cali\n    Aeropuerto(\"BOG\", 300, 500, -500), // Bogota\n    Aeropuerto(\"MDE\", 200, 600, -500), // Medellin\n    Aeropuerto(\"BAQ\", 350, 850, -500), // Barranquilla\n    Aeropuerto(\"SMR\", 400, 950, -500), // Santa Marta\n    Aeropuerto(\"CTG\", 300, 800, -500), // Cartagena (Corregí Y de 500 a 800 para que SMR-PTY no sea más corto)\n    Aeropuerto(\"PTY\", 400, 1000, -500), // Ciudad de Panama\n    Aeropuerto(\"JFK\", 2000, 2000, -400), // Nueva York\n    Aeropuerto(\"MIA\", 1000, 2000, -500), // Miami\n    Aeropuerto(\"MEX\", 1000, 1000, -600), // Ciudad de Mexico\n    Aeropuerto(\"MAD\", 5000, 5000, 100), // Madrid\n    Aeropuerto(\"SVCS\", 400, 1000, -600), // Caracas\n    Aeropuerto(\"MID\", 500, 1000, -600), // Merida\n    Aeropuerto(\"AUA\", 500, 2000, -400), // Aruba\n    Aeropuerto(\"IST\", 9000, 9000, 300), // Estambul\n    Aeropuerto(\"HND\", 10000, 12000, 900), // Tokio\n    Aeropuerto(\"DXB\", 9500, 11500, 400), // Dubai\n    Aeropuerto(\"SVO\", 12500, 12500, 300) // Moscu\n  )\n\n  val vuelosCurso: List[Vuelo] = List(\n    Vuelo(\"AIRVZLA\", 601, \"MID\", 5, 0, \"SVCS\", 6, 0, 0),\n    Vuelo(\"AIRVZLA\", 602, \"SVCS\", 6, 30, \"MID\", 7, 30, 0),\n    Vuelo(\"AVA\", 9432, \"CLO\", 7, 0, \"SVO\", 2, 20, 4),\n    Vuelo(\"AVA\", 9433, \"CLO\", 7, 0, \"BOG\", 8, 0, 0),\n    Vuelo(\"IBERIA\", 505, \"BOG\", 18, 0, \"MAD\", 12, 0, 0),\n    Vuelo(\"IBERIA\", 506, \"MAD\", 14, 0, \"SVO\", 23, 20, 0),\n    Vuelo(\"IBERIA\", 507, \"MAD\", 16, 0, \"SVO\", 1, 20, 0),\n    Vuelo(\"LATAM\", 787, \"BOG\", 17, 0, \"MEX\", 19, 0, 0),\n    Vuelo(\"VIVA\", 756, \"BOG\", 9, 0, \"MDE\", 10, 0, 0),\n    Vuelo(\"VIVA\", 769, \"MDE\", 11, 0, \"BAQ\", 12, 0, 0),\n    Vuelo(\"AVA\", 5643, \"BAQ\", 14, 0, \"MEX\", 16, 0, 0),\n    Vuelo(\"COPA\", 1234, \"CTG\", 10, 0, \"PTY\", 11, 30, 0),\n    Vuelo(\"AVA\", 4321, \"CTG\", 9, 30, \"SMR\", 10, 0, 0),\n    Vuelo(\"COPA\", 7631, \"SMR\", 10, 50, \"PTY\", 11, 50, 0),\n    Vuelo(\"TURKISH\", 7799, \"CLO\", 7, 0, \"IST\", 14, 0, 3),\n    Vuelo(\"QATAR\", 5566, \"IST\", 23, 0, \"SVO\", 2, 0, 0)\n  )\n\n\n  // FUNCIONES BASICAS DE ITINERARIOS // \n\n  def itinerarios(vuelos: List[Vuelo], aeropuertos: List[Aeropuerto]): (String, String) => List[Itinerario] = {\n    val vuelosPorOrigen = vuelos.groupBy(_.Org)\n    val codsValidos = aeropuertos.map(_.Cod).toSet\n\n    // Función recursiva que busca todos los itinerarios desde un aeropuerto de origen (cod1) hasta un destino (cod2)\n    def buscarItinerarios(cod1: String, cod2: String, visitados: Set[String]): List[Itinerario] = {\n      if (cod1 == cod2) {\n        List(Nil)\n      } else {\n        // Obtenemos los vuelos que salen del aeropuerto actual\n        val vuelosSalientes = vuelosPorOrigen.getOrElse(cod1, Nil)\n        // Y filtramos los que conducen a aeropuertos aún no visitados\n        val vuelosValidos = vuelosSalientes.filter(v => !visitados.contains(v.Dst))\n\n        // Exploramos recursivamente los destinos posibles, concatenando el vuelo actual con el resto del itinerario\n        for {\n          vuelo <- vuelosValidos\n          resto <- buscarItinerarios(vuelo.Dst, cod2, visitados + cod1)\n        } yield vuelo :: resto\n      }\n    }\n\n    // Función que devolvemos\n    (cod1: String, cod2: String) => {\n      // Verificamos que ambos códigos correspondan a aeropuertos válidos\n      if (!codsValidos.contains(cod1) || !codsValidos.contains(cod2)) {\n        List()\n      } else {\n        // Si es válido, tons iniciamos la búsqueda recursiva desde el aeropuerto de origen hacia el destino\n        buscarItinerarios(cod1, cod2, Set())\n      }\n    }\n  }\n\n\n\n  def itinerariosPar(vuelos: List[Vuelo], aeropuertos: List[Aeropuerto]): (String, String) => List[Itinerario] = {\n    val vuelosPorOrigen = vuelos.groupBy(_.Org)\n    val codsValidos = aeropuertos.map(_.Cod).toSet\n\n    def buscarItinerariosPar(cod1: String, cod2: String, visitados: Set[String]): List[Itinerario] = {\n      // Caso base: llegó al destino\n      if (cod1 == cod2) {\n        List(Nil)\n      } else {\n        val vuelosSalientes = vuelosPorOrigen.getOrElse(cod1, Nil)\n        val vuelosValidos = vuelosSalientes.filter(v => !visitados.contains(v.Dst))\n\n        // Umbral: Si hay 1 o 0 vuelos, es más rápido hacerlo secuencial.\n        if (vuelosValidos.length <= 1) {\n          for {\n            vuelo <- vuelosValidos\n            resto <- buscarItinerariosPar(vuelo.Dst, cod2, visitados + cod1)\n          } yield vuelo :: resto\n        } else {\n          // Cada vuelo se procesa en su propia tarea.\n          val tasks = for (vuelo <- vuelosValidos)\n            yield task {\n              val subItinerarios = buscarItinerariosPar(vuelo.Dst, cod2, visitados + cod1)\n              subItinerarios.map(resto => vuelo :: resto)\n            }\n          (for (t <- tasks) yield t.join()).flatten\n        }\n      }\n    }\n\n    (cod1: String, cod2: String) => {\n      if (!codsValidos.contains(cod1) || !codsValidos.contains(cod2)) {\n        List()\n      } else {\n        buscarItinerariosPar(cod1, cod2, Set())\n      }\n    }\n  }\n\n\n\n\n\n\n  // --- FUNCIÓN SECUENCIAL A PROBAR ---\n\n  def itinerariosEscalas(vuelos: List[Vuelo], aeropuertos: List[Aeropuerto]): (String, String) => List[Itinerario] = {\n    (cod1: String, cod2: String) => {\n\n      def calcularEscalas(itinerario: Itinerario): Int = {\n        val escalasTecnicas = itinerario.map(_.Esc).sum\n        val escalasPorConexion = if (itinerario.isEmpty) 0 else itinerario.length - 1\n        escalasTecnicas + escalasPorConexion\n      }\n\n      val todosLosItinerarios = itinerarios(vuelos, aeropuertos)(cod1, cod2)\n      val itinerariosOrdenados = todosLosItinerarios.sortBy(calcularEscalas)\n      itinerariosOrdenados.take(3)\n    }\n  }\n\n  def itinerariosEscalasPar(vuelos: List[Vuelo], aeropuertos: List[Aeropuerto]): (String, String) => List[Itinerario] = {\n\n    // Función principal que usamos para buscar rutas entre dos códigos.\n      (codOrigen, codDestino) => {\n\n        // Helper para sumar las escalas de todos los vuelos de una ruta\n        def calcularEscalas(itinerario: List[Vuelo]): Int = itinerario.map(_.Esc).sum\n\n        /**\n         * Busca todos los caminos (DFS).\n         * El 'visitados' es para no dar vueltas.\n         */\n        def buscarItinerario(origenActual: String, destinoFinal: String, visitados: Set[String], itinerarioActual: List[Vuelo]): List[Itinerario] = {\n\n          // Caso base: Llegamos al destino\n          if (origenActual == destinoFinal) List(itinerarioActual)\n\n          else {\n            // Vuelos que salen de aquí y van a un sitio nuevo\n            val vuelosDisponibles = vuelos.filter(vuelo => vuelo.Org == origenActual && !visitados.contains(vuelo.Dst))\n\n            //  Busca rutas desde cada vuelo disponible\n            vuelosDisponibles.par.flatMap(vuelo => \n              buscarItinerario(vuelo.Dst, destinoFinal, visitados + origenActual, itinerarioActual :+ vuelo)\n            ).toList // Volvemos a List normal.\n          }\n        }\n\n        // Encontramos todas las rutas posibles.\n        val todosLosItinerarios = buscarItinerario(codOrigen, codDestino, Set(), List())\n\n        // Ordenamos: el que tenga menos escalas va primero.\n        val itinerariosOrdenados = todosLosItinerarios.sortBy(calcularEscalas)\n\n        // Devolvemos el TOP 3 de rutas.\n        itinerariosOrdenados.take(3)\n      }\n    }\n\n\n  // --- BLOQUE DE EJECUCIÓN ---\n\n  println(\"--- ✈️ Iniciando Pruebas de Itinerarios ---\")\n\n  val vuelosPrueba = vuelosCurso\n  val aeropuertosPrueba = aeropuertosCurso\n  val itsEscalasPar = itinerariosEscalasPar(vuelosPrueba, aeropuertosPrueba)\n\n  // --- PRUEBA 1: MID -> SVCS (Vuelo único) ---\n  println(\"\\n--- PRUEBA 1: MID -> SVCS ---\")\n  val itsel_par = itsEscalasPar(\"MID\", \"SVCS\")\n  println(s\"Paralelo:   $itsel_par\")\n\n  // --- PRUEBA 2: CLO -> SVCS (No conectado) ---\n  println(\"\\n--- PRUEBA 2: CLO -> SVCS ---\")\n  val itsel2_par = itsEscalasPar(\"CLO\", \"SVCS\")\n  println(s\"Paralelo:   $itsel2_par\")\n\n  // --- PRUEBA 3: CLO -> SVO (Caso clave) ---\n  println(\"\\n--- PRUEBA 3: CLO -> SVO ---\")\n  val itsel3_par = itsEscalasPar(\"CLO\", \"SVO\")\n  println(s\"Paralelo:   $itsel3_par\")\n\n  // --- PRUEBA 4: CLO -> MEX ---\n  println(\"\\n--- PRUEBA 4: CLO -> MEX ---\")\n  val itsc4_par = itsEscalasPar(\"CLO\", \"MEX\")\n  println(s\"Paralelo:   $itsc4_par\")\n\n  // --- PRUEBA 5: CTG -> PTY ---\n  println(\"\\n--- PRUEBA 5: CTG -> PTY ---\")\n  val itsc5_par = itsEscalasPar(\"CTG\", \"PTY\")\n  println(s\"Paralelo:   $itsc5_par\")\n\n  println(\"\\n--- ✅ Pruebas Completadas ---\")\n\n} // Cierre del 'object Main'","size_bytes":8871}},"version":2}